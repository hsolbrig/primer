var Parser = require("./json-grammar.js");
var FS = require('fs');
var Assert = require("assert");
var OBJ = ">";
var EXP = "="

function Missing (attr, obj) {
  var ret = Error("expected \"" + attr + "\" in " + obj);
  ret.type = "Missing";
  ret.object = obj;
  ret.attribute = attr;
  return ret;
}

function Unexpected (attr, obj) {
  var ret = Error("unexpected \"" + attr + "\": \"" + obj[attr] + "\" in " + obj);
  ret.type = "Unexpected";
  ret.object = obj;
  ret.attribute = attr;
  return ret;
}
// thrower for inline conditionals
function throwUnexpected (attr, obj) { throw Unexpected(attr, value); }

function Expected (attr, value, obj) {
  var msg =
    "Expected \"" + attr + "\"" +
    (value === undefined ? "" : " to equal \"" + value + "\"") +
    (!obj ? "" : " in " + obj);
  var ret = Error(msg);
  ret.type = "unexpected";
  ret.object = obj;
  ret.attribute = attr;
  ret.value = value;
  return ret;
}

function Epsilon (obj) {
  var ret = Expected("expected " + JSON.stringify(elt) + " to be empty.");
  ret.type = "Epsilon";
  ret.object = obj;
  return ret;
}

function NoMatching999 (attr, values, obj) {
  var msg = !obj ?
    "Expected \"" + attr + "\" to equal \"" + value + "\"" :
    "Expected \"" + attr + "\": \"" + obj[attr] + "\" to equal \"" + value + "\" in " + obj;
  var ret = Error(msg);
  ret.type = "NoMatching";
  ret.object = obj;
  ret.attribute = attr;
  ret.value = value;
  return ret;
}

function novel (elt, key, known) {
  return known.indexOf(key) === -1 ? elt[key] : undefined;
}

function Schema (schema) {
  return {
    validator: function () {
      return {
        validateLeafType: function (elt, ft, known, lead) {
          var _validator = this;
          if (ft[0] === "\"") {
            if (elt === ft.slice(1, -1)) {
              return [];
            } else {
              return [Expected(elt, ft.slice(1, -1))];
            }
          }
          var refd = schema.map[ft];
          if (refd.type === "object") {
            return this.validateObject(elt, ft, lead);
          } else if (refd.type === "nonObject") {
            return this.validateExpr(elt, refd.expr, known, lead);
          } else if (refd.type === "terminal") {
            if (!(""+elt).match(RegExp(refd.regexp))) {
              return [Expected(elt, refd.regexp)];
            }
            return [];
          } else {
            throwUnexpected("type", refd);
          }
        },
        validateType: function (elt, t, known, lead) {
          var _validator = this;
          if (typeof t !== "object") {
            return _validator.validateLeafType(elt, t, known, lead);
          } else if (t instanceof Array) {

            var subErrors;
            var subKnown;
            for (var i = 0; i < t.length; ++i) { // for(;;) for early return
              var disj = t[i];
              subKnown = known.slice();
              subErrors = this.validateLeafType(elt, disj, subKnown, lead);
              if (subErrors.length === 0) {
                known.push(disj)
                return [];
              }
            }
            return [Error("no matching option testing " + JSON.stringify(elt) + " against " + JSON.stringify(t))];
          } else if (t.type === "array") {
            return elt.reduce(function (ret, e) {
              return ret.concat(_validator.validateLeafType(e, t.of, known, lead+EXP));
            }, []);
          } else if (t.type === "map") {
            return Object.keys(elt).reduce(function (ret, from) {
              return ret.concat(_validator.validateLeafType(from, t.from, known, lead+EXP)).
                concat(_validator.validateLeafType(elt[from], t.to, known, lead+EXP));
            }, []);
          } else {
            throwUnexpected("type", t);
          }
        },
        validateProperty: function (elt, prop, known, lead, propName) {
          if (prop.type === "epsilon") {
            return elt === undefined ? [] : [Unexpected(propName, elt)];
          }
          if (elt === undefined) {
            if (false && prop.card === "?") {
              return [];
            } else {
              return [Expected(propName, undefined, elt)];
            }
          }
          return this.validateType(elt, prop.propertyType, known, lead);
        },
        validatePropertyEnumeration: function (elt, prop, known, lead) {
            var subErrors;
            var subKnown;
            for (var i = 0; i < prop.ids.length; ++i) { // for(;;) for early return
              var disj = prop.ids[i];
              subKnown = known.slice();
              subErrors = this.validateProperty(novel(elt, disj, known), prop, subKnown, lead, disj);
              if (subErrors.length === 0) {
                known.push(disj)
                return [];
              }
            }
            return [Error("no matching enum testing " + JSON.stringify(elt) + " against " + JSON.stringify(prop))];
        },
        validateReference: function (elt, nob, known, lead) {
          return this.validateLeafType(elt, nob.id, known, lead);
        },
        validatePropertyList: function (elt, list, known, lead) {
          var _validator = this;
          var errors = [];
          list.forEach(function (li) {
            errors = errors.concat(_validator.validateExpr(elt, li, known, lead+EXP));
            // console.log(lead, "T      choice testing ", elt, " for ", li);
            // var t = _validator.validateExpr(elt, li, known, lead+EXP);
            // var disposition = t.length === 0 ? "PASSED" : "FAILED";
            // console.log(lead, disposition, " choice testing ", elt, " for ", li, " yielded ", t);
            // errors = errors.concat(t);
          });
          return errors;
        },
        validateEpsilon: function (ep) {
          return "<span class=\"comment\"># empty</span>";
        },
        validateExpr: function (elt, expr, known, lead) {
          var _validator = this;
          // console.log(lead, expr);

          function testCard (test) {
            var matched = 0; // for reference(?), property(?|*) and propertyEnumeration(?|*)
            var lastErrors;
            var lastKnown;
            do {
              lastKnown = known.length;
              if ((lastErrors = test()).length === 0) {
                ++matched;
              }
            } while (expr.card === "*" && known.length !== lastKnown && lastErrors.length === 0);
            if (matched === 1 ||
                expr.card === "?" && matched === 0 ||
                expr.card === "*") {
              return [];
            } else {
              return  expr.card === "" ? lastErrors : [Error("unexpected " + matched + " matching " + JSON.stringify(expr))]
            }
          }

          switch (expr.type) {
            // reference, property and propertyEnumeration can have a cardinality
          case "reference":
            return testCard(function () {
              return _validator.validateReference(elt, expr, known, lead+EXP);
            });

          case "property":
//                known.push(expr.id);
            return testCard(function () {
              var e = _validator.validateProperty(novel(elt, expr.id, known), expr, known, lead, expr.id);
              if (e.length === 0) {
                known.push(expr.id);
              }
              return e;
            });

          case "propertyEnumeration":
            return testCard(function () {
              return _validator.validatePropertyEnumeration(elt, expr, known, lead+EXP);
            });

          case "propertyList":
            return _validator.validatePropertyList(elt, expr.exprs, known, lead);

          case "or":
            var subErrors;
            var subKnown;
            for (var i = 0; i < expr.exprs.length; ++i) { // for(;;) for early return
              var disj = expr.exprs[i];
              subKnown = known.slice();
              subErrors = _validator.validateExpr(elt, disj, subKnown, lead);
              if (subErrors.length === 0) {
                subKnown.slice(known.length).forEach(function (i) { known.push(i); }) // concatonate into existing array.
                return [];
              }
            }
            return [Error("no matching enum testing " + JSON.stringify(elt) + " against " + JSON.stringify(expr))];

          case "epsilon":
            known.push(expr.id)
            return [];

          default:
            throwUnexpected("type", expr);
          }
        },
        validateObject: function (elt, as, leadp) {
          var _validator = this;
          var lead = leadp + as+OBJ;
          Assert(elt instanceof Object);
          Assert(as !== undefined);
          var defn = schema.map[as];
          Assert(defn.type === "object");
          Assert(defn !== undefined);
          Assert("type" in elt);
          if (elt.type !== as) { return [Expected("type", as, elt)]; }
          var known = ["type"];
          var errors = this.validateExpr(elt, defn.expr, known, lead);
          // console.log(lead, "known:", known);
          // console.log(lead, "shown:", Object.keys(elt));
          var unexpected = known.reduce(function (ret, ob) {
            var i = ret.indexOf(ob);
            if (i !== -1) {
              ret.splice(i, 1);
            }
            return ret;
          }, Object.keys(elt));
          if (unexpected.length !== 0) {
            unexpected.forEach(function (u) {
              errors.push(Unexpected(u, elt));
            });
          }
          return errors;
        },
        validate: function (elt) {
          return this.validateObject(elt, schema.start, "");
        }
      };
    },
    htmlSerializer: function () {
      return {
        serializeLeafType: function (ft) {
          if (ft[0] === "\"") {
            return ft.slice(1,-1);
          }
          var dt = 
            schema.map[ft].type === "object" ? "objref" :
            schema.map[ft].type === "nonObject" ? "nobref" :
            schema.map[ft].type === "terminal" ? "trmref" :
            throwUnexpected("type", schema.map[ft]);
          var anchor = schema.map[ft].type === "nonObject" ? "#dfn-" + ft : "#dcl-" + ft;
          return "<a class=\"" + dt + "\" href=\"" + anchor + "\">" + ft + "</a>";
        },
        serializeType: function (t) {
          var _htmlSerializer = this;
          return (typeof t !== "object") ? _htmlSerializer.serializeLeafType(t) :
            t instanceof Array ? "(" + t.map(function (ti) {
              return _htmlSerializer.serializeLeafType(ti);
            }).join("|") + ")" :
          t.type === "array" ? "[" + _htmlSerializer.serializeLeafType(t.of) + "]" :
            t.type === "map" ? "[" + _htmlSerializer.serializeLeafType(t.from) + "-&gt;" + _htmlSerializer.serializeLeafType(t.to) + "]" :
            throwUnexpected("type", t);
        },
        serializeProperty: function (prop) {
          return prop.id + ":" + this.serializeType(prop.propertyType) + prop.card;
        },
        serializePropertyEnumeration: function (prop) {
          return "("+prop.ids.join("|")+")" + ":" + this.serializeType(prop.propertyType) + prop.card;
        },
        serializeReference: function (nob) {
          return "<a class=\"nobref\" href=\"#dfn-" + nob.id + "\">" + nob.id + "</a>" + nob.card
        },
        serializePropertyList: function (list) {
          var _htmlSerializer = this;
          return list.map(function (li) {
            // !!! return _htmlSerializer.serializeExpr(li);
            return li.type === "property" ? _htmlSerializer.serializeProperty(li) :
              li.type === "or" ? "(" + li.exprs.map(function (oi) {
                return _htmlSerializer.serializeProperty(oi);
              }).join("|") + ")" :
            li.type === "reference" ? _htmlSerializer.serializeReference(li) :
              li.type === "propertyEnumeration" ? _htmlSerializer.serializePropertyEnumeration(li) :
              throwUnexpected("type", li);
          }).join(" ");
        },
        serializeEpsilon: function (ep) {
          return "<span class=\"comment\"># empty</span>";
        },
        serializeExpr: function (expr) {
          return expr.type === "reference" ? this.serializeReference(expr) :
            expr.type === "property" ? this.serializeProperty (expr) :
            expr.type === "propertyEnumeration" ? this.serializePropertyEnumeration(expr) :
            expr.type === "propertyList" ? this.serializePropertyList (expr.exprs) :
            // expr.type === "or" ? "(" + expr.exprs.map(function (oi) {
            //     return _htmlSerializer.serializeProperty(oi);
            //   }).join("|") + ")" :
            expr.type === "epsilon" ? this.serializeEpsilon (expr) :
            throwUnexpected("type", expr);
        },
        serialize: function () {
          var _htmlSerializer = this;
          var needTerminalsHeading = true;
          var ret = schema.order.map(function (id) {
            var production = schema.map[id];
            if (production.type === "object" || production.type === "nonObject") {
              var rows = production.expr.type === "or" ? production.expr.exprs : [production.expr];
              var rowspan = rows.length === 1 ? "" : " rowspan=\"" + rows.length + "\"";
              var punctuation = production.type === "object" ? ":" : "=";
              return "<tr class=\"obj\"><th" + "" + ">" + production.id + "</th><td>" + punctuation + "</td><td>" + _htmlSerializer.serializeExpr(rows[0]) + "</td></tr>\n" +
                rows.slice(1).map(function (r) {
                  return "    <tr class=\"obj\"><th></th><td>|</td><td>" + _htmlSerializer.serializeExpr(r) + "</td></tr>\n"
                }).join("");
            // } else if (production.type === "nonObject") {
            //   return "<tr class=\"nob\"><th>" + production.id + "</th><td>=</td><td>" + production.vals.map(function (val) {
            //     var obj = schema.map[val];
            //     return "<span class=\"" + obj.type + "_ref\">" + val + "</span>";
            //   }).join("|") + "</td></tr>\n";
            } else if (production.type === "terminal") {
              var heading = "";
              if (needTerminalsHeading) {
                heading = "<tr><th></th><th colspan=\"2\" style=\"text-align: left;\">Terminals</th></tr>\n";
                needTerminalsHeading = false;
              }
              return heading + "<tr class=\"trm\"><th>" + production.id + "</th><td>=</td><td>" + production.regexp + "</td></tr>\n";
            } else {
              throw Unexpected("type", production);
            }
          }).map(function (s) { return "  " + s; });
          return "<table>\n" + ret.join("") + "</table>\n";
        }
      };
    }
  };
}

var p = Parser.parse(FS.readFileSync(process.argv[2], "utf8"));
// console.log(JSON.stringify(p, null, 2));
var s = Schema(p);
// console.log(s.htmlSerializer().serialize());
var errors = s.validator().validate(JSON.parse(FS.readFileSync(process.argv[3], "utf8")))
console.log("errors:", errors);
process.exit(errors.length === 0 ? 0 : 1);
